
# 什么是性能优化

### 1.概述

### 2.低性能的影响

* 用户的留存
* 网站的转换率
* 体验与传播

#### 2.1 用户的留存
网站用户的留存情况，一般指的是用户自登录注册之日起，经过一段时间后，仍然还在使用该网站的用户数。统计出注册用户数与留存用户数后，就可以计算出用户留存率，这个指标对网站的运营有重要的指导意义。

#### 2.2 网站转换率
网站转化率指的是用户进行了某项目标行为的访问次数与总访问次数的比率。某项目标行为可以是用户注册、资源下载、商品购买等一系列用户行为


#### 2.3 体验与传播
用户为过多的流量数据支付相应的费用，若所访问网站包含的资源文件过大、组织冗余，用户便会浪费过多的网络资费，同时过大的资源传输量也会延长请求响应的时间，最终降低用户的体验度。


### 3.性能优化评估模型

#### RAIL性能模型
> 以用户位中心, 使用Chrome的RAIL模型位参考标准

* **R-Response响应**
* **A-Animation动画**
* **I-Idle(空闲)**
* **L-Load加载**

#### 用户感知延迟
将用户作为之后性能优化的中心，首先需要了解用户对于延迟的反应。用户感知延迟的时间窗口

![[Pasted image 20250327102708.png]]


#### R-Response

**概述**
> 网站性能对于响应方面的要求是，在用户感知延迟之前接收到操作的反馈。比如用户进行了文本输入、按钮单击、表单切换及启动动画等操作后，==必须在100ms内收到反馈==，如果超过100ms的时间窗口，用户就会感知延迟。

****

**如何做?**
* 将较大开销的工作放在后台异步执行，而即便后台处理要数百毫秒才能完成的操作，也应当给用户提供及时的阶段性反馈。


#### A-Animation
**概述**
> 人眼具有视觉暂留特性，就是当光对视网膜所产生的视觉在光停止作用后，仍能保留一段时间。研究表明这是由于视神经存在反应速度造成的，其值是1/24s
> 对动画来说，无论动画帧率有多高，最后我们仅能分辨其中的==30帧==，但越高的帧率会带来更好的流畅体验，==因此动画要尽力达到60fps的帧率==。

这里的30帧是怎么计算出来的?
> 无法直接得出


#### I-Idle

**概述**
> 以用户为中心来看待性能问题，就会发现并非所有工作都需要在响应和加载阶段完成，我们完全可以利用浏览器的空闲时间处理可延迟的任务，只要让用户感受不到延迟即可。
> 利用空闲时间处理延迟，可减少预加载的数据大小，以保证网站或应用快速完成加载。
> 为了更加合理地利用浏览器的空闲时间，==最好将处理任务按50ms为单位分组==。这么做就是保证用户在发生操作后的100ms内给出响应。



#### L-Load

**概述**
> 用户感知要求我们尽量在1s内完成页面加载，如果没有完成，用户的注意力就会分散到其他事情上，并对当前处理的任务产生中断感。
> 这里在1s内完成加载并渲染出页面的要求，并非要完成所有页面资源的加载，从用户感知体验的角度来说，==只要关键渲染路径完成，用户就会认为全部加载已完成。==





# 性能优化的概述

### 概述
1. 首先可量化地评估出网站或应用的性能表现；
2. 然后立足于网站页面响应的生命周期，分析出造成较差性能表现的原因；
3. 最后进行技术改造、可行性分析等具体的优化实施。


### 1.性能测量

#### 1.1 Chrome浏览器-Performance功能
>该工具分析页面资源加载、渲染、请求响应等各环节耗费的时间线，据此便可分析一定程度的性能问题


#### 1.2 Lighthouse
>根据所提供的网站URL从性能、可访问性、渐进式Web应用、SEO（搜索引擎优化）等多个方面进行自动化分析，最终给出一份具有指导意义的报告。
>还会经常用到的性能测试工具有PageSpeed Insights、WEBPAGETEST、Pingdom等


### 2 生命周期
> 在浏览器的地址栏中输入一个URL后，到整个页面渲染出来的过程。

![[Pasted image 20250327105014.png]]

### 3.优化方案
先简单扼要地介绍一些优化方面的思路。
(1)传输资源的优化，比如图像资源，不同的格式类型会有不同的使用场景，在使用的过程中是否恰当。
(2)加载过程的优化，比如延迟加载，是否有不需要在首屏展示的非关键信息，占用了页面加载的时间。
(3)JavaScript是现代大型网站中相当“昂贵”的资源，是否进行了压缩，书写是否规范，有无考虑内存泄漏等。
(4)关键渲染路径优化，比如是否存在不必要的重绘和回流。
(5)本地存储和浏览器缓存


## 前端页面的生命周期

### 1.访问URL的流程概述

1. 浏览器接收到URL，解析URL, 然后是通过'渲染进程'发出网络请求线程
2. 一个完整的HTTP请求的发出分两步
	1. DNS解析(浏览器-系统自身->host->本地域名服务器->迭代查询根域名服务器->顶级域名服务器->权威域名服务器)
	2. 通信链路建立(TCP3次握手->4次挥手)
3. 服务器接收到请求并转到具体的处理后台
	1. 一般是反向代理服务器先处理
	2. 然后进入后台处理, 最终结果以http响应包形式发送
4. 前后台之间的HTTP交互和涉及的缓存机制
	1. HTTP1.0/HTTP1.1/HTTP2.0不同的处理机制
	2. 强缓存/协商缓存
5. 浏览器接收到数据包后的关键渲染路径
	1. 构建对象模型(DOM对象模型, CSSOM对象模型)
	2. 将两个对象合并为渲染树
6. JS引擎的解析过程
	1. JS更改渲染树的结构, 重新执行渲染流程

感觉上面的描述并不充分, 提供其它版本:
[[02_浏览器&HTTP&Git#输入网址后发生了什么]]

### 2.网络请求线程开启
> 浏览器接收到我们输入的URL到开启网络请求线程，这个阶段是在浏览器内部完成的

#### 1. 解析URL&新建线程
##### 1.解析URL
URL结构：`Protocol：//Host：Port/Path？Query#Fragment`

![[Pasted image 20250327141920.png]]


##### 2.新建进程
解析URL后，如果是HTTP协议，则浏览器会新建一个==网络请求线程==去下载所需的资源


#### 进程与线程(了解)
##### 概述
>简单来说，进程就是一个程序运行的实例，操作系统会为进程创建独立的内存，用来存放运行所需的代码和数据；
>而线程是进程的组成部分，每个进程至少有一个主线程及可能的若干子线程，这些线程由所属的进程进行启动和管理。
>关系: 由于多个线程可以共享操作系统为其所属的同一个进程所分配的资源，所以多线程的并行处理能有效提高程序的运行效率。


**示例图**

![[Pasted image 20250327142352.png]]


##### 进程与线程的关系特点
* 只要某个线程执行出错，将会导致整个进程崩溃。
* 进程与进程之间相互隔离。这保证了当一个进程挂起或崩溃的情况发生时，并不会影响其他进程的正常运行，虽然每个进程只能访问系统分配给自己的资源，但可以通过IPC机制进行进程间通信。
* 进程所占用的资源会在其关闭后由操作系统回收。即使进程中存在某个线程产生的内存泄漏，当进程退出时，相关的内存资源也会被回收。
* 线程之间可以共享所属进程的数据


##### 单进程浏览器与多进程浏览器
**单进程浏览器**
![[Pasted image 20250328132142.png]]






**多进程浏览器**
浏览器把原先单进程内功能相对独立的模块抽离为单个进程处理对应的任务，主要分为以下几种进程。


![[Pasted image 20250328132204.png]]



**1.浏览器主进程-**
一个浏览器只有一个主进程，负责如菜单栏、标题栏等界面显示，文件访问，前进后退，以及子进程管理等。

**2.GPU进程**
GPU（图形处理单元）最初是为了实现3D的CSS效果而引入的，后来随着网页及浏览器在界面中的使用需求越来越普遍，Chrome便在架构中加入了GPU进程

**3.插件进程**
主进程会为每个加入浏览器的插件开辟独立的子进程，由于进程间所分配的运行资源相对独立，所以即便某个插件进程意外崩溃，也不至于对浏览器和页面造成影响。另外，出于对安全因素的考虑，这里采用了沙箱模式（即图2.3中虚线所标出的进程）​，在沙箱中运行的程序受到一些限制：不能读取敏感位置的数据，也不能在硬盘上写入数据。这样即使插件运行了恶意脚本，也无法获取系统权限。

**4.网络进程**
负责页面的网络资源加载，之前属于浏览器主进程中的一个模块，最近才独立出来。


**5.渲染进程**
也称为浏览器内核，其默认会为每个标签窗口页开辟一个独立的进程，负责将HTML、CSS和JavaScript等资源转为可交互的页面，其中包含多个子线程，即JS引擎线程、GUI渲染线程、事件触发线程、定时触发器线程、异步HTTP请求线程等。

当打开一个标签页输入URL后，所发起的网络请求就是从这个进程开始的。另外，出于对安全性的考虑，渲染进程也被放入沙箱中。






### 3.建立HTTP请求
这个阶段的主要工作分为两部分：DNS解析和通信链路的建立。

#### 1.DNS解析
> 其主要目的便是通过查询将URL中的Host字段转化为网络中具体的IP地址

![[Pasted image 20250328133710.png]]

**步骤**
1. 首先查询浏览器自身的DNS缓存，如果查到IP地址就结束解析，由于缓存时间限制比较大，一般只有1分钟，同时缓存容量也有限制，
2. 如果没找到,搜索系统自身的DNS缓存；
3. 如果还未找到，接着就会尝试从系统的hosts文件中查找
4. 本地主机还没找到, 在本地域名服务器上查询
5. 如果本地域名服务器上没有找到, 则本地域名服务器便会采取迭代的方式去依次查询根域名服务器、COM顶级域名服务器和权限域名服务器等
6. 最终没有找到, 报错

DNS查询是很耗时的过程, 若解析的域名过多，势必会延缓首屏的加载时间。


#### 2.网络模型了解

在通过DNS解析获取到目标服务器IP地址后，就可以建立网络连接进行资源的请求与响应了。但需要对网络架构模型有一些基本的认识.
国际标准化组织提出了一些网络架构模型：OSI模型、TCP/IP模型

![[Pasted image 20250328134049.png]]

##### OSI(开发系统互连)
OSI（开放系统互连）模型将网络从底层的物理层到顶层浏览器的应用层一共划分了7层, 其作用分别是:
![[Pasted image 20250328134125.png]]


##### TCP连接

##### 三次握手
由于TCP是面向有连接的通信协议，所以在数据传输之前需要建立好客户端与服务器端之间的连接，即通常所说的“三次握手”​，具体过程如下:
1. 客户端生成一个随机数seq，假设其值为t，并将标志位SYN设为1，将这些数据打包发给服务器端后，客户端进入等待服务器端确认的状态。
2. 服务器端收到客户端发来的SYN=1的数据包后，知道这是在请求建立连接，于是服务器端将SYN与ACK均置为1，并将请求包中客户端发来的随机数t加1后赋值给ack，然后生成一个服务器端的随机数seq=k，完成这些操作后，服务器端将这些数据打包再发回给客户端，作为对客户端建立连接请求的确认应答。
3. 客户端收到服务器端的确认应答后，检查数据包中ack的字段值是否为t+1，ACK是否等于1，若都正确就将服务器端发来的随机数加1(ack=k+1)，将ACK=1的数据包再发送给服务器端以确认服务器端的应答，服务器端收到应答包后通过检查ack是否等于k+1来确认连接是否建立成功。连接建立的关系图如图2.7所示。

![[Pasted image 20250328134545.png]]


##### 四次挥手
当用户关闭标签页或请求完成后，TCP连接会进行“四次挥手”​，具体过程如下。

1. 由客户端先向服务器端发送FIN=M的指令，随后进入完成等待状态FIN_WAIT_1，表明客户端已经没有再向服务器端发送的数据，但若服务器端此时还有未完成的数据传递，可继续传递数据。
2. 当服务器端收到客户端的FIN报文后，会先发送ack=M+1的确认，告知客户端关闭请求已收到，但可能由于服务器端还有未完成的数据传递，所以请客户端继续等待。
3. 当服务器端确认已完成所有数据传递后，便发送带有FIN=N的报文给客户端，准备关闭连接。
4. 客户端收到FIN=N的报文后可进行关闭操作，但为保证数据正确性，会回传给服务器端一个确认报文ack=N+1，同时服务器端也在等待客户端的最终确认，如果服务器端没有收到报文则会进行重传，只有收到报文后才会真正断开连接。而客户端在发送了确认报文一段时间后，没有收到服务器端任何信息则认为服务器端连接已关闭，也可关闭客户端信息。连接关闭的关系图如图2.8所示。
![[Pasted image 20250328134729.png]]


















### 4.前后端交互

> 当TCP连接建立好之后，便可通过HTTP等协议进行前后端的通信，但在实际的网络访问中，并非浏览器与确定IP地址的服务器之间直接通信，往往会在中间加入反向代理服务器。


#### 1.反向代理服务器
> 对需要提供复杂功能的网站来说，一般采用的方式是将多个应用服务器组成的集群由反向代理服务器提供给客户端用户使用，这些功能服务器可能具有不同类型，比如文件服务器、邮件服务器及Web应用服务器，同时也可能是相同的Web服务部署到多个服务器上，以实现负载均衡的效果，反向代理服务器的作用如图

常用作反向代理服务器的有Nginx、IIS、Apache

**作用**
* 负载均衡
* 安全防火墙
* 加密及SSL加速
* 数据压缩
* 解决跨域
* 静态资源缓存

![[Pasted image 20250328145655.png]]




#### 2.后端处理流程
经反向代理收到请求后，具体的服务器后台处理流程大致如下
(1)首先会有一层统一的验证环节，如跨域验证、安全校验拦截等。如果发现是不符合规则的请求，则直接返回相应的拒绝报文。

(2)通过验证后才会进入具体的后台程序代码执行阶段，如具体的计算、数据库查询等。
(3)完成计算后，后台会以一个HTTP响应数据包的形式发送回请求的前端，结束本次请求。


#### 3.HTTP协议特性

HTTP是建立在传输层TCP协议之上的应用层协议，在TCP层面上存在长连接和短连接的区别。
**长连接**，就是在客户端与服务器端建立的TCP连接上，可以连续发送多个数据包，但需要双方发送心跳检查包来维持这个连接。
**短连接**就是当客户端需要向服务器端发送请求时，会在网络层IP协议之上建立一个TCP连接，当请求发送并收到响应后，则断开此连接。

如果这个过程频繁发生，就是个很大的**性能耗费**，所以从HTTP的1.0版本开始对于连接的优化一直在进行。

**在HTTP 1.0时**，默认使用短连接，浏览器的每一次HTTP操作就会建立一个连接，任务结束则断开连接。

**在HTTP 1.1时**，默认使用长连接，在此情况下，当一个网页的打开操作完成时，其中所建立用于传输HTTP的TCP连接并不会断开关闭，客户端后续的请求操作便会继续使用这个已经建立的连接。请求头设置Connection：keep-alive。持续时间由服务器设置.


在HTTP 2.0到来之前，每一个资源的请求都需要开启一个TCP连接，由于TCP本身有并发数的限制，这样的结果就是，当请求的资源变多时，速度性能就会明显下降.解决方案就是: 将静态资源的请求进行多域名拆分，对于小图标或图片使用雪碧图等。

**在HTTP 2.0之后**，便可以在一个TCP连接上请求多个资源，分割成更小的帧请求，其速度性能便会明显上升，所以之前针对HTTP 1.1限制的优化方案也就不再需要了。




**HTTP2.0特性**
* 二进制分帧：在应用层和传输层之间，新加入了一个二进制分帧层，以实现低延迟和高吞吐量。
* 服务器端推送：以往是一个请求带来一个响应，现在服务器可以向客户端的一个请求发出多个响应，这样便可以实现服务器端主动向客户端推送的功能。
* 设置请求优先级：服务器会根据请求所设置的优先级，来决定需要多少资源处理该请求。
* HTTP头部压缩: 减少报文体积




#### 4.浏览器缓存
> 在基于HTTP的前后端交互过程中，使用缓存可以使性能得到显著提升。具体的缓存策略分为两种：强缓存和协商缓存。

##### 强缓存
强缓存就是当浏览器判断出本地缓存未过期时，直接读取本地缓存，无须发起HTTP请求，此时状态为：200 from cache。
在HTTP1.1版本后通过头部的cache-control字段的**max-age**属性值规定的过期时长来判断缓存是否过期失效，这比之前使用**expires**标识的服务器过期时间更准确而且安全。


##### 协商缓存
协商缓存则需要浏览器向服务器发起HTTP请求，来判断浏览器本地缓存的文件是否仍未修改，若未修改则从缓存中读取，此时的状态码为：304。
具体过程是判断浏览器头部**if-none-match**与服务器短的**e-tag**是否匹配，来判断所访问的数据是否发生更改。这相比HTTP 1.0版本通过last-modified判断上次文件修改时间来说也更加准确。

![[Pasted image 20250328155006.png]]





#### 5.关键渲染路径
> 当我们经历了网络请求过程，从服务器获取到了所访问的页面文件后，浏览器如何将这些HTML、CSS及JS文件组织在一起渲染出来呢？


##### 1.构建对象模型
浏览器会通过解析HTML和CSS文件，来构建DOM（文档对象模型）和CSSOM（层叠样式表对象模型）​


**浏览器构建DOM模型的过程**
1. 浏览器读取指定编码(UTF-8)的原始字节(形如3C62 6F 79 3E 65 6C 6F 2C 20 73 70), 将字节转换为代码字符串
2. 再将字符串转换为W3C标准规定的令牌结构(令牌: HTML中不同标签代表不同含义的一组规则结构)
3. 经过词法分析将令牌转换成定义了属性和规则值的对象
4. 最后, 将标签节点根据HTML表示的父子关系,连接成树形结构.

![[Pasted image 20250328203519.png]]
![[Pasted image 20250328202817.png]]
**浏览器构建CSSOM模型**
和将HTML文件解析为文档对象模型的过程类似, 
1. CSS文件也会首先经历从字节到字符串
2. 然后令牌化及词法分析后
3. 构建为层叠样式表对象模型
![[Pasted image 20250328203537.png]]
![[Pasted image 20250328203552.png]]


##### 2.渲染绘制
当完成文档对象模型和层叠样式表对象模型的构建后，所得到的其实是描述最终渲染页面两个不同方面信息的对象：一个是展示的文档内容，另一个是文档对象对应的样式规则，接下来就需要将两个对象模型合并为**渲染树**，渲染树中只包含渲染可见的节点

**渲染步骤**
1. 从所生成DOM树的根节点开始向下遍历每个子节点，忽略所有不可见的节点（脚本标记不可见、CSS隐藏不可见）​，因为不可见的节点不会出现在渲染树中。
2. 在CSSOM中为每个可见的子节点找到对应的规则并应用。
3. 布局阶段，根据所得到的渲染树，计算它们在设备视图中的具体位置和大小，这一步输出的是一个“盒模型”​。
4. 绘制阶段，将每个节点的具体绘制方式转化为屏幕上的实际像素。

执行构建渲染树、布局及绘制过程所需要的时间取决于实际文档的大小。所以关键渲染路径执行快慢，将直接影响首屏加载时间的性能指标。

当首屏渲染完成后，用户在和网站的交互过程中，有可能通过JavaScript代码提供的用户操作接口更改渲染树的结构，一旦DOM结构发生改变，这个渲染过程就会重新执行一遍。可见对于关键渲染路径的优化影响的不仅是首屏性能，还有交互性能。



# 具体的性能优化
> 原书关于这里的叙述太繁琐了, 还是将原书的内容分类到两个方面(更快的请求, 更快的渲染)下.

## 优化途径
* 更快的渲染
* 更快的请求

## 更快的渲染-图片
> 图像优化问题主要可以分为两方面：**图像的选取和使用**，**图像的加载和显示**。
> 图像资源优化的根本思想，可以归结为两个字：压缩。

### 1.背景知识
#### 1.分类
* 矢量图
* 位图

**矢量图**
* 适合如文本、品牌logo、控件图标及二维码等构图形状较简单的几何图形
* 优点是能够在任何缩放比例下呈现出细节同样清晰的展示效果。其缺点是对细节的展示效果不够丰富，对足够复杂的图像来说例如照片，svg实现体积会很大
* SVG标签所包括的部分就是该矢量图的全部内容，除了必要的绘制信息，可能还包括一些元数据，比如XML命名空间、图层及注释信息。在使用前可通过工具==去除这些元数据==来达到压缩的目的。

**位图**
* 位图是通过对一个矩阵中的栅格进行编码来表示图像的
* 栅格像素色块，每个像素存储的是图像局部的RGBA信息，即红绿蓝三色通道及透明度。通常浏览器会为每个颜色通道分配一个字节的存储空间，即28=256个色阶值。
* 一个像素点4个通道就是4字节, 当图像尺寸为100像素×100像素时，文件大小为39KB

![[Pasted image 20250329004634.png]]


#### 2.分辨率
> 相同的图像及相同的设置，其渲染出来的图像可能清晰度有差别,可能原因是屏幕分辨率和图像分辨率

**图像分辨率**表示的就是该图像文件所包含的真实像素值信息，比如一个200像素×200像素的分辨率的图像文件，它就定义了长宽各200个像素点的信息。

**设备分辨率**则是显示器屏幕所能显示的最大像素值，比如一台13英寸的Mac Pro笔记本电脑的显示器分辨率为2560像素×1600像素。


**区别**
10像素×10像素的图像分辨率，既可以使用10像素×10像素的设备分辨率来显示，又可以使用20像素×20像素或40像素×40像素的设备分辨率来显示

![[Pasted image 20250329005024.png]]

从上图中可以看出: 更高的设备分辨率有助于显示更绚丽多彩的图像

对矢量图来说: 适合
对位图来说: 只有其包含更多的像素信息时, 才能更充分的利用分辨率. 为了能在不同分辨率下展示合适的是图片, 可以利用==picture标签和srcset属性==提供图像的多个变体。

**srcset**
> 除了IE浏览器和其它较低版本浏览器不支持



**picture**
> 控制维度更多,如屏幕方向,设备大小,屏幕分辨率等. 新标准,考虑兼容性


![[Pasted image 20250329005533.png]]


#### 3.有损压缩,无损压缩

根据业务需求来进行, 一般通过自动化流程完成


#### 4.图像格式
> 不同的图像文件格式（JPG、PNG、GIF等）之间的区别，在于它们进行有损压缩和无损压缩过程中采用了不同的算法组合

##### 图像格式列表:
* JPEG
* GIF
* PNG
* WebP
* SVG
* Base64

##### **图像格式选择的建议**
![[Pasted image 20250329115455.png]]


* 用到图标的场景应尽量使用矢量图
* 由于在相同图像质量下其具有更高的压缩比且支持动画，所以WebP格式应该是我们的首选。
* 考虑到新技术的兼容性, 传统方式: 
	* 动画使用GIF; 
	* 对图像要求有更高分辨率来展示细节且需要透明度时，建议使用PNG；
	* 在其他场景下追求更高的图像压缩比时，可使用JPEG
	* 对于不同缩放比的响应式场景，建议提供多张不同尺寸的图像


#### 5.使用建议
##### 1.雪碧图CSS Sprite
> 通过将多张小图标拼接成一张大图，有效地减少HTTP请求数量以达到加速显示内容的技术

条件标准:
* 首先这些图标不会随用户信息的变化而变化，它们属于网站通用的静态图标；
* 同时单张图标体积要尽量小，这样经过拼接后其性能的提升才会比较乐观

使用方式:
通过CSS的background-image属性引入雪碧图的URL后，再使用background-position定位所需要的单个图标在雪碧图上的起始位置，配合width和height属性来锁定具体图标的尺寸


现状:
* 在HTTP 1.x环境下，它确实能够减少相应的HTTP请求
* 在HTTP 2中，最好的方式应该是加载单张图像文件，因为可以在一个HTTP连接上发起多次请求
* 对于是否使用此方法，需要考虑具体的使用环境和网络设置


##### 2.Web字体的使用

**基本使用:**
* 在Web项目中，一般会先通过@font-face声明使用的字体系列
![[Pasted image 20250329121645.png]]

**子集内嵌,实现字体按需加载**
> 通过@font-face和unicode-range属性就可以定义所使用的字体子集

属性unicoderange用来指定所需字体在@font-face声明字体集中的子集范围，它支持三种形式：单一取值（如U+233）​、范围取值（如U+233-2ff）​、通配符范围（如U+2？​？​）​，取值的含义是字体集文件中的代码索引点
![[Pasted image 20250329121826.png]]

注意: 存在兼容性问题, 使用前需要确认


**字体文件预加载**
> 可使用〈link rel="preload"〉对字体资源进行预加载




**display:none在图片上使用注意事项**

img1.jpg的图像文件会被请求。
下面img2.jpg的图像文件不会发起请求
```html
<div style="display: none">
	<img src="imgs1.jpg" />
</div>
```



```html
<div style="display: none">
	<div style="background: url(img2.jpg)"></div>
</div>
```



### 2.如何进行图片优化

1.[[#**图像格式选择的建议**]]
* 矢量图优先
* 位图首选WebP,注意兼容处理
* 删除图像文件中多余的元数据
* 图像文件压缩
* 响应式要求的提供多种尺寸图像
* 工程化通用处理流程实现自动化
2.[[#1.雪碧图CSS Sprite]]
3.[[#2.Web字体的使用]]: 字体子集内嵌+字体预加载
4.display:none+图片



## 更快的渲染-加载优化

### 1.图像延迟加载

#### 概述
>首次打开网站时，应尽量只加载首屏内容所包含的资源，而首屏之外涉及的图片或视频，可以等到用户滚动视窗浏览时再去加载。

#### 图片延迟加载怎么做?

##### 方案1-传统方式
> 事件监听的方式，通过监听scroll事件与resize事件，并在事件的回调函数中去判断，需要进行延迟加载的图片是否进入视窗区域

**实现步骤:**
1.定义好要延迟加载的img标签结构
```html
<img class="lazy" src="placeholder.jpg" data-src="image-to-lazy-1x.jpg" alt="i'm an image">
```

关注class属性, src属性(可用base64图片或低分辨率图片), data-src属性(通过该自定义属性保存图片真实的URL外链。)

2.在文档的DOMContentLoaded事件中，添加延迟加载处理逻辑. 
1. 首先获取class属性名为lazy的所有〈img〉标签，将这些标签暂存在一个名为lazyImages的数组中，表示需要进行延迟加载但还未加载的图片集合。
2. 当一个图片被加载后，便将其从lazyImages数组中移除
3. 直到lazyImages数组为空时，表示所有待延迟加载的图片均已经加载完成，此时便可将页面滚动事件移除。

3.接下来的关键就是判断图片是否出现在视窗中(使用了getBoundingClientRect()函数获取元素的相对位置)

代码实现:
```
<img
	class="lazy"
	src="data:img/gif;base64, iVBORw0KGg...BjRU5ErkJggg=="
	data-src="https://res.cloudinary.com/.../tacos-2x.jpg"
	width="385" height="108" alt="some tacos">


<img
	class="lazy"
	src="data:img/gif;base64, iVBORw0KGg...BjRU5ErkJggg=="
	data-src="https://res.cloudinary.com/.../modem-2x.jpg"
	width="320" height="176" alt="some tacos">



<img
	class="lazy"
	src="data:img/gif;base64, iVBORw0KGg...BjRU5ErkJggg=="
	data-src="https://res.cloudinary.com/.../st-paul-2x.jpg"
	width="400" height="267" alt="some tacos">

```


![[Pasted image 20250329141730.png]]

存在的问题:
* scroll事件被触发地过于频繁，导致过多的冗余计算影响性能; 原方案中采用延迟加载处理
* 完全加载完后，取消绑定滚动事件的处理函数等操作都需要开发者来考虑。


##### 方案2-Intersection Observer方式
**概述:**
> 每当因页面滚动或窗口尺寸发生变化，使得目标元素(target)与设备视窗或其他指定元素产生交集时，便会触发通过Intersection ObserverAPI配置的回调函数，在该回调函数中进行延迟加载的逻辑处理，会比传统方式显得更加简洁而高效。

![[Pasted image 20250329142216.png]]

使用注意熟悉的:
* 存在兼容性问题: 传统浏览器使用传统方式,
* 使用相应兼容的polyfill插件

**特点**
* 足够简单
* 并非所有浏览器都支持


##### 方式3-CSS类名方式
概述
> 通过CSS的background-image属性来加载图片，与判断〈img〉标签src属性是否有要请求图片的URL不同，CSS中图片加载的行为建立在浏览器对文档分析基础之上.
> 当生成渲染之后, 浏览器会去检查CSS以何种方式应用于文档, 再决定是否请求外部资源.


实现方式
* 通过JavaScript来判断元素是否出现在视窗中的，当在视窗中时，为其元素的class属性添加visible类名。
* 在CSS文件中，为同一类名元素定义出带.visible和不带.visible的两种包含background-image规则。
* 

![[Pasted image 20250329153010.png]]

![[Pasted image 20250329153029.png]]

![[Pasted image 20250329153044.png]]


![[Pasted image 20250329153215.png]]



##### 方案4-原生加载延迟支持

概述
> 从Chrome 75版本开始，已经可以通过〈img〉和〈iframe〉标签的loading属性原生支持延迟加载了

loading属性包含以下三种取值。
* lazy：进行延迟加载。
* eager：立即加载。
* auto：浏览器自行决定是否进行延迟加载。

若不指定任何属性值，loading默认取值auto。下面是具体的代码使用场景：
![[Pasted image 20250329153447.png]]

注意: 
在图像即将滚动出现在屏幕视窗之前一段距离，就开始请求加载图像或iframe中的内容，这样能很好地缩短用户的等待加载时长。

兼容性处理:
```js
<script>
	if ('loading' in HTMLImageElement.prototype) {
		// 浏览器支持loading='lazy'的延迟加载方式
	} else {
		// 获取其它JS库来实现延迟加载
	}

</script>
```

实现方式:
* 浏览器支持loading加载, JS处理程序中src属性赋值为真实图像资源地址
* 浏览器不支持loading加载, 默认将真实图像地址挂在data-src属性上, 当触发延迟加载滚动事件时, 才将data-src属性的值赋值到src属性上
* 还可以使用CSS类名方式触发对资源加载, 这种方式要等到loading属性在浏览器引入稳定版本loading后使用

```html
<img data-src='photo.jpg' loading='lazy' class='lazyload' alt='photo' />
```


### 2.视频加载
> 通过〈video〉引入的视频资源也可进行延迟加载


#### 请求流程
即在HTML完成加载和解析时触发DOMContentLoaded事件开始请求视频资源，当请求完成后触发window.onload事件开始页面渲染

#### 如何进行视频渲染优化

##### 1.不自动播放
>通过视频标签的preload进行控制,阻止不需要自动播放的视频的预加载

```html
<video controls preload="none" poster="default.jpg">
	<source src="simply.webm" type="video/webm">
	<source src="simply.mp4" type="video/mp4">
</video>
```

##### 2.视频代替gif动画
> 尽量用视频代替尺寸过大的GIF动画

![[Pasted image 20250329160316.png]]

实现浏览器的兼容性, 延迟加载
* video标签添加poster属性,提供视频占位
* 将真实视频地址暂存data-src, 基于Intersection Observer用JavaScript实现对延迟加载的控制
![[Pasted image 20250329160412.png]]


![[Pasted image 20250329160644.png]]



### 3.加载注意事项

#### 1.首屏加载
* 首屏上的内容就不应当进行延迟加载，而应使用正常加载的方式
* 对首屏视窗之外的媒体资源采用延迟加载，而对首屏内的媒体资源采用正常的方式加载
* 但由于网站页面所呈现的设备屏幕尺寸多种多样，因此如何判断首屏视窗的边界，目前也没有完全行之有效的方法来完美地处理每种设备的情况。

#### 2.资源占位
> 当延迟加载的媒体资源未渲染出来之前，应当在页面中使用相同尺寸的占位图像

**实现方式**
* 使用一个与目标媒体资源长宽相同的纯色占位符
* 或者像之前使用的Base64图片,
* 或LQIP或SQIP等方法

#### 3.内容加载失败
> 在发生任何资源加载故障时，给予用户必要的通知提示，总好过直接让用户无奈地面对故障

* 当图片资源未能按预期成功加载时，采取措施依情况而定

```js
//图片加载失败处理-添加错误处理方法

const newImage = new Image()
newImage.src = 'photo.jpg';
//发生故障时的处理措施
newImage.onerror = err => {}
//图像加载后的回调
newImage.onload = () => {};
```

#### 4.图像解码延迟


#### 5.JS是否可用
> 让占位符图像在JavaScript不可用时不可见，但其体验效果会比让用户只看到占位符图像和没有意义的图像内容要好许多

1. html添加`no-js`类, 并声明相应的css文件 `.no-js .lazy {display: none}`
2. 在head标签中放置内联脚本, 当JS可用时, 移除no-js类: 
3. 在延迟加载图片占位符后,添加noscript脚本
```js
<script>document.documentElement.classList.remove('no-js')</script>
```

```html
//使用延迟加载的图像文件标签
<img class="lazy" src="placeholder-image.jpg" data-src="image-to-lazy-load.jpg" alt="photo" />

//当js不可用时,原生展示目标图像
<noscript>
	<img src="iamge-to-lazy-load.jpg" alt="photo" />
</noscript>
```




### 4.资源优先级

#### 背景
* 浏览器通常都会采取启发式算法，对所要加载的内容先进行推测，将相对重要的信息优先呈现给用户，比如先加载CSS文件，然后再去加载JavaScript脚本和图像文件。
* 无法保证所有情况下都是准确的


#### 概述
* 浏览器基于自身的启发式算法，会对资源的重要性进行判断来划分优先级，通常从低到高分为：Lowest、Low、High、Highest等
* 在〈head〉标签中，CSS文件通常具有最高的优先级Highest，其次是〈script〉标签所请求的脚本文件，但当〈script〉标签带有defer或async的异步属性时，其优先级又会降为Low。

![[Pasted image 20250330164018.png]]


#### 如何更改优先级

##### 1.预加载
**1. 使用**
> 使用〈link rel="preload"〉标签告诉浏览器当前所指定的资源，应该拥有更高的优先级

```html
<link rel="preload" as="script" href="important.js" >
<link rel="preload" as="style" href="critical.css">
```

* as 表示要加载的资源类型
* preload会强制浏览器预加载
* 如果预加载指定的资源在3s内未被当前页面使用，则浏览器会在开发者工具的控制台中进行警告提示，该警告务必要处理


**2.实例**
1.字体的使用
* 'corossorigin'需要添加,否则不会对字体预加载
```html
<link rel="preload" as="font" crossorigin="crossorigin" type="font/woff2" href="yfont.woff2" >
```


2.关键路径的渲染
* 使用〈link rel="preload"〉对单个文件进行预加载，除了能很快地请求资源，还能尽量利用缓存



##### 2.预连接
* 通过〈link rel="preconnect"〉标签指令，告知浏览器当前页面将与站点建立连接，希望尽快启动该过程。
* 如果建立好连接后的10s内，未能及时使用连接，那么浏览器关闭该连接后，之前为建立连接所消耗的资源就相当于完全被浪费掉了。

**1.实例**
```html
//预连接
<link rel="preconnect" href="https://example.com">

//dns预解析
<link rel="dsn-prefetch"  xxxx>
```

##### 3.预提取

**1.概述**
* 利用机会让某些非关键操作能够更早发生,  以Lowest的优先级进行提起。
* 预提取最适合的场景是为用户下一步可能进行的操作做好必要的准备
* 预提取不能递归使用
* 预提取不会降低现有资源的优先级

## 更快的渲染-JS

### 一些建议
* 使用位操作优化数学运算
* 使用原生操作优化数学运算
* 推荐使用window中的requestAnimationFrame方法代替setInterval方法可能出现的抖动/卡顿现象
* 将一些纯计算的工作迁移到WebWorker上处理
* 事件节流和事件防抖


## 更快的渲染-CSS
### 1.减少计算样式的元素数量
> CSS引擎在查找样式表时，对每条规则的匹配顺序是从右向左的

#### 如何做?
* 使用类选择器代替标签选择器
* 避免使用通配符
* 降低选择器的复杂性
* 使用BEM规范

#### BEM规范
> BEM是一种CSS的书写规范，它的名称是由三个单词的首字母组成的，分别是块(Block)、元素(Element)和修饰符(Modifier).
> 理论上它希望每行CSS代码只有一个选择器.
> 对选择器的命名要求通过以下三个符号的组合来实现。

中画线(`-`)：仅作为连字符使用，表示某个块或子元素的多个单词之间的连接符。
单下画线(`_`)：作为描述一个块或其子元素的一种状态。
双下画线(`__`)：作为连接块与块的子元素。

```css
type-block__element_modifier
```


### 2.重排和重绘的优化

#### 1.触发布局与重绘的操作有哪些?
这些操作大致可以分为三类：
* 首先就是对DOM元素几何属性的修改,这些操作大致可以分为三类：首先就是对DOM元素几何属性的修改
* 其次是更改DOM树的结构. 对DOM树节点的增、删、移动等操作，只会影响当前节点后的所有节点元素，而不会再次影响前面已经遍历过的元素
* 最后一类是获取某些特定的属性值操作，比如offsetWidth、offsetHeight，offsetTop、offsetLeft，还有scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientWidth、clientHeight及调用window.getComputedStyle方法。


#### 2.如何避免频繁的重排与重绘
* 使用类名对样式逐条修改.合理的做法是，将多行的样式修改合并到一个类名中，仅在JavaScript脚本中添加或更改类名即可
* 缓存对敏感属性值的计算
* 使用requestAnimationFrame方法控制渲染帧







## 更快的渲染-构建优化

### 1.压缩与合并

#### 1.HTML压缩
#### 2.CSS压缩

#### 3.JS压缩与混淆

#### 4.文件合并

### 2.脚手架优化




## 更快的渲染-服务端渲染







## 更快的请求

## 更快的请求-数据存储

### 数据存储的分类


![[Pasted image 20250330175622.png]]




## 更快的请求-缓存

### 1概述
> 缓存的原理是在首次请求后保存一份请求资源的响应副本，当用户再次发起相同请求后，如果判断缓存命中则拦截请求，将之前存储的响应副本返回给用户，从而避免重新向服务器发起资源请求。


### 2.分类
大致可以分为两类：共享缓存和私有缓存。共享缓存指的是缓存内容可被多个用户使用，如公司内部架设的Web代理；私有缓存指的是只能单独被用户使用的缓存，如浏览器缓存。

### 浏览器缓存
#### 分类
* 内存中的缓存
* Service Worker缓存
* HTTP缓存
* HTTP 2的Push缓存
#### 优先级
优先级从高到低分别是：内存中的缓存、Service Worker缓存、HTTP缓存及HTTP 2的Push缓存

![[Pasted image 20250330185915.png]]
#### HTTP缓存

##### 1.强制缓存(强缓存)
* 相关字段是expires和cache-control, 
* expires是HTTP1.0协议中的字段, cache-control是HTTP1.1中的字段
* expires存在漏洞, 引入了cache-control来解决
* cache-control相关值
	* no-cache和no-store. 两个互斥属性,不能同时设置
		* no-cache: 表示为强制进行协商缓存
		* no-store: 表示禁止使用任何缓存策略，客户端的每次请求都需要服务器端给予全新的响应
	* private和public
		* 表示响应资源既可以被浏览器缓存，又可以被代理服务器缓存。
		* private限制了响应资源只能被浏览器缓存，若未显式指定则默认值为private。
	* max-age和s-maxage
		* max-age表示服务器端告知客户端浏览器响应资源的过期时长
		* 表示缓存在代理服务器中的过期时长，且仅当设置了public属性值时才有效


##### 协商缓存
* 协商缓存判断缓存有效的响应状态码是304，即缓存有效响应重定向到本地缓存上
* 相关字段是last-modified(HTTP1.0)和ETag(HTTP1.1)
*


##### 缓存决策树
![[Pasted image 20250330183540.png]]



##### 缓存设置注意事项
恰当的缓存策略都需要根据具体场景下的请求资源类型、数据更新要求及网络通信模式等多方面因素考量后制定出来
* 拆分源码，分包加载
* 预估资源的缓存时效
* 控制中间代理的缓存
* 避免网址的冗余
* 规划缓存的层次结构


#### service-worker缓存
##### 是什么
>Service Worker是浏览器后台独立于主线程之外的工作线程
>还能实现诸如推送通知、后台同步、请求拦截及缓存管理等功能
>是伴随着Google推出的PWA（即Progressive Web App渐进式Web应用）一同出现的技术
>但在各端上的兼容性并不理想,应用比较多的还是在基于Chrome的PC端浏览器上




#### Push缓存
##### 是什么
>HTTP 2新增了一个强大的功能：服务器端推送，它的出现打破了传统意义上的请求与响应一对一的模式，服务器可以对客户端浏览器的一个请求发送多个响应。


### CDN缓存

#### 概述

**未使用CDN网络**进行缓存加速时, 浏览器访问网站获取资源的过程:

(1)当用户在浏览器中输入所要访问的域名时，若本机无法完成域名解析工作，则会转向DNS服务器请求对该域名的解析。
(2)DNS服务器解析完成返回给浏览器该域名所对应的IP地址。
(3)浏览器向该IP地址指向的服务器发起资源请求。
(4)最后服务器响应用户请求将资源返回给浏览器。

**使用CDN缓存**
(1)由于DNS服务器将对CDN的域名解析权交给了CNAME指向的专用DNS服务器，所以对用户输入域名的解析最终是在CDN专用的DNS服务器上完成的。
(2)解析出的结果IP地址并非确定的CDN缓存服务器地址，而是CDN的负载均衡器的地址。
(3)浏览器会重新向该负载均衡器发起请求，经过对用户IP地址的距离、所请求资源内容的位置及各个服务器复杂状况的综合计算，返回给用户确定的缓存服务器IP地址。
(4)对目标缓存服务器请求所需资源的过程。











## 前端性能检测

### 如何进行性能检测
* 精力有限, 推荐使用Lighthouse工具。
* 专注检测, 除了Lighthouse工具, 还有Chrome任务管理器, Network面板, Coverage面板, Memory面板, Performance面板, Performance monitor面板, PageSpeed Insights工具, WEBPAGETEST


### Lighthouse介绍


#### 1. 3种使用方式
* Chrome扩展程序
* Chrome开发者工具
* Nodejs命令行


#### 2.性能状况
> 关于性能状况部分的检测结果，Lighthouse给出的信息包括：检测得分、性能指标、优化建议、诊断结果及已通过的性能，下面来分别进行介绍。

##### 2.1 检测得分
![[Pasted image 20250327113429.png]]

##### 2.2 性能指标
* 首次内容绘制时间(First Content Paint)
* 最大内容绘制时间(Largest Contentful Paint)
* 总阻塞时间(Total Blocking Time)
* 累积布局偏移(Cumulative Layout Shift)
* 速度指数(Speed Index)

![[Pasted image 20250327114845.png]]


##### **FCP**
> https://developer.chrome.com/docs/lighthouse/performance/first-contentful-paint/?utm_source=lighthouse&utm_medium=devtools#how_lighthouse_determines_your_fcp_score



##### **LCP**
> https://developer.chrome.com/docs/lighthouse/performance/lighthouse-largest-contentful-paint/?utm_source=lighthouse&utm_medium=devtools



##### **TBT**
> https://developer.chrome.com/docs/lighthouse/performance/lighthouse-total-blocking-time/?utm_source=lighthouse&utm_medium=devtools


##### **CLS**
> https://web.dev/articles/cls?utm_source=lighthouse&utm_medium=devtools



##### **SI**
>https://developer.chrome.com/docs/lighthouse/performance/speed-index/?utm_source=lighthouse&utm_medium=devtools


##### 2.3 优化建议
Lighthouse在给出关键性能指标评分的同时，还提供了一些切实可行的优化建议
这些建议按照优化后预计能带来的提升效果从高到低进行排列，每一项展开又会有更加详细

* 移除阻塞渲染的资源
* 预连接所要请求的源，提前建立与所要访问资源之间的网络连接，或者加快域名的解析速度都能有效地提高页面的访问性能
	* 一种是设置〈linkrel="preconnect"〉的预连接
	* 另一种是设置〈link rel="dns-prefetch"〉的DNS预解析
* 降低服务器端响应时间
* 适当调整图片大小，使用大小合适的图片可节省网络带宽并缩短加载用时，此处的优化建议通常对于本应使用较小尺寸的图片就可满足需求，但却使用了高分辨率的大图，对此进行适当压缩即可。
* 移除未使用的CSS






### Performance面板

#### 1概述
使用Performance面板主要对网站应用的运行时性能表现进行检测与分析，其可检测的内容不仅包括页面的每秒帧数(FPS)、CPU的消耗情况和各种请求的时间花费，还能查看页面在前1ms与后1ms之间网络任务的执行情况









