

## 考试内容









### Part1 计算机科学基础

### 1.考点
> 掌握数制及转换, 数据的表示, 算术运算和逻辑运算, 数学应用
> 掌握常用数据结构和算法

### 难点
1)数据的3种编码——原码、反码、补码，以及它们之间的变换方法。
2)浮点数的表示法及其规格化。
3)常用数据结构，其中二叉树及其遍历、链表尤为重要。
4)图的存储（矩阵、邻接表）与遍历、算法效率的计算（时间、空间复杂度）​、6种常见的排序算法、哈希表（散列表）及其解决冲突的方法。

#### ![[11_01.jpg]]



## 数制及转换

### 数制是什么
> 数值是用(一组固定的)符号和(统一的)规则来表示数值的方法.

### r进制
> 在采用**进位计数**的数字系统中, 如果只用r个基本符号来表示数值, 则称其为r进制, r称为该数值的基数.

### 常用进位计数表格
![[13_01.jpg]]

以十进制的2021.25为例的表示形式:


$$
\begin{align}
\text {十进制表示为 } (2021.25)_{10} \text{ 或 } 2021.25D \\
\text {二进制表示为 } (11111100101.01)_{2} \text{ 或 } 11111100101.01B \\
\text {八进制表示为 } (3745.2)_{8} \text{ 或 } 3745.2O \\
\text {十六进制表示为 } (7E5.4)_{16} \text{ 或 } 7E5.4H
\end{align}
$$


### 进制转换

原理: ?
任何一种进位的数制, 所表示的数制都可以写作==**按权展开的多项式**==, 不同数据的相互转换也是依据此实现的.

例如:
$$
(2021.25)_{10} = 2×10^{3} + 0*10^{2} + 2*10^{1} +| 1*10^{0} + 2*10^{-1} + 5*10^{-2}
$$

#### 十进制转二进制:

**整数部分除2取余, 余数倒序排列
小数部分乘2取整, 整数正序排列**

计算过程略, 本章位置为: 1.1.3.1 数制及其转换

那十进制转8进制, 16进制分别是除8 和 除16.

#### **二进制转十进制呢?**
> 方法: 将二进制数的每一位数乘以它的权后相加。

$$
(11111100101.01)_{2}=1×2^{10}+1×2^{9}+1×2^{8}+1×2^{7}+1×2^{6}+1×2^{5}+0×2^{4}+0×2^{3}+1×2^{2}+0×2^{1}+1×2^{0}+0×2^{-1}+1×2^{-2}=(2021.25)_{10}
$$

#### **二进制转8进制**
> 取三合一法，即以二进制的小数点为分界点，向左（或向右）每三位取成一位。

![[14_01.jpg]]

$$
(11111100101.01)_{2} = (3745.2)_{8}
$$

转换过程如下:(位数不足则补位)
![[14_02.jpg]]



## 数据的表示

### 原码, 反码, 补码
> 二进制数值数据包括二进制表示的定点小数、整数和浮点数。这里讲的编码方法，主要是如何方便统一地表示正数、零和负数，并且尽可能有利于简化对它们实现算术运算用到的规.
> **机器数**:  通常把表示一个数值数据的机内编码称为机器数;
> **真值**:  把表示一个数值的数据所代表的实际值称为机器数的真值。

### 1.原码
#### 定义
> 定义: 原码是一种比较直观的机器数表示方法，最高位是符号位，0代表正号，1代表负号，数值部分用该数的绝对值表示。

原码的定义:


$$
[X]_{\text{原}} = 
\begin{cases}
X, & 0 \leq X < 1 \\
1 - X, & -1 < X \leq 0
\end{cases}
$$

分段函数:
* 当X值的范围是`0<= X < 1`时, X的原值就是X
* 当X值的范围是`-1<X<=0`时, X的原值就是`1-X`

#### 表示范围
原码的表示范围受限于位数（如 8 位、16 位、32 位等）.

注意: 通过查询deepSeek得出, 如果需使用原码来表示更大范围的数, 可以通过**固定位数**表示更大范围的数值.


**对于一个 n 位的原码：**
- **最高位是符号位**：0 表示正数，1 表示负数。

- **剩余 n−1 位是数值位**：表示数值的绝对值。

所以, 原码的表示范围是:
$$
- (2^{n-1} - 1) \leq X \leq 2^{n-1} - 1 ]
$$

#### 性质
1. 在原码表示中, 机器数的最高位是符号位, 0表示正号, 1表示负号
2. 在原码表示中, 零有两种表示形式

$$
\begin{align}
[+0.0] &= 00000
\\
[-0.0] &= 10000
\\
注意: 5位只是例子
\end{align}
$$

#### 优缺点
##### 优点
* 数的真值与原码表示之间对应关系简单, 相互转换容易
* 用原码实现乘除运算的规则简单

##### 缺点
* 表示范围是对称的, 但是存在两个问题:  
	1. **零的表示不唯一**：有 +0 和 −0 两种表示; 
	2. **表示范围有限**
* 不利于计算机中应用最多的加减运算, 故计算机中一般不用原码.

> 在乘除运算方便的原因: 在乘除运算中, 符号和数值可以分开处理, 与人类手工计算方式相同.
> 在加减运算不方便的原因:  如果一个加一个减,需要比较绝对值大小,然后大的减去小的,再赋予结果正确的符号. 增加了硬件设备设计的复杂性,降低了运算效率.
> 还有, 零的不唯一表示. 会导致在加减计算中额外处理零的情况, 增加复杂性.


### 反码

#### 定义
> 当真值为正数时，反码与原码相同；
> 当真值为负数时，反码的符号位用1表示，数值位是原码的各位取反（1变0，0变1）的结果


$$
\begin{align}

[X]_{反} = 
\begin{cases}

X  & 0 \leq X<1 \\
(2-2^{-n}) + X & -1<X\leq0

\end{cases}
\end{align}
$$












#### 算术运算和逻辑运算



## 考试大纲
#### 科目1

![[Pasted image 20250403225427.png]]

![[Pasted image 20250403225444.png]]


* 分梯队, 考试频次高的优先复习
* 办公软件不考


#### 科目2
![[Pasted image 20250403225651.png]]





## 计算机组成与体系结构(分值7-11)



### 进制的转换

![[Pasted image 20250404214409.png]]


![[Pasted image 20250404214420.png]]



![[Pasted image 20250404214430.png]]



![[Pasted image 20250404214439.png]]



![[Pasted image 20250404214447.png]]


![[Pasted image 20250404214455.png]]

![[Pasted image 20250404214502.png]]



### 含符号位数值标识



![[Pasted image 20250404212521.png]]



#### 考点1-转换规则
![[Pasted image 20250404212542.png]]

#### 考点2-0的表示
![[Pasted image 20250404212849.png]]

#### 考点3-表示范围
![[Pasted image 20250404213434.png]]




![[Pasted image 20250404213516.png]]





### 浮点数
![[Pasted image 20250404214234.png]]


#### 考点1-浮点数表示
![[Pasted image 20250404214250.png]]


#### 考点2-浮点数加减运算过程

![[Pasted image 20250404214307.png]]


#### 考点3-浮点数转二进制
![[Pasted image 20250404214321.png]]

![[Pasted image 20250404214330.png]]

![[Pasted image 20250404214338.png]]













### 逻辑代数及其运算
![[Pasted image 20250404211609.png]]



#### 考点1-逻辑运算规则
![[Pasted image 20250404211640.png]]


#### 考点2-真值表
![[Pasted image 20250404211929.png]]


![[Pasted image 20250404212440.png]]

* 按位非运算的结果取决于原数的二进制表示，对于非零数进行按位非运算，结果可能为零也可能不为零，因此无法直接判断其结果是否为零。











### 校验码
![[Pasted image 20250404210718.png]]


#### 考点1-奇偶校验码
![[Pasted image 20250404210748.png]]


#### 考点2/3-海明码/循环冗余校验码

![[Pasted image 20250404211245.png]]



![[Pasted image 20250404211302.png]]

![[Pasted image 20250404211542.png]]










### 中央处理器

![[Pasted image 20250404203404.png]]



#### 考点1
![[Pasted image 20250404203423.png]]


1. 中央处理器执行过程基于冯诺依曼体系，由五大部件构成：运算器、控制器、输入设备、输出设备和存储器。
2. 计算机系统分为两大部分：主机部分和外部设备部分，其中主机部分是核心，包含CPU和主存储器（内存）。
3. CPU作为计算机的核心部件，由运算器、控制器和寄存器组,内部总线组这几部分组成，负责数据的处理和控制。
4. 主存储器，或称为内存，位于主机中，主要用于临时存储和刷新数据，支持CPU的运行。
5. 外部设备部分包括输入设备、输出设备和外部存储设备，与主机通过数据流和控制流进行信息交换。


#### 考点2/3-运算器/控制器
![[Pasted image 20250404203937.png]]


1. 运算器主要包含算术逻辑运算单元和累加寄存器，其中算术逻辑运算单元负责执行算术和逻辑运算，累加寄存器用于暂时存储运算结果，供其他对象使用。
2. 控制器的核心部件包括程序计数器和指令寄存器，程序计数器用于存储下一条要执行指令的地址，并自动加1以指向后续指令，指令寄存器则存放正在执行的指令。
3. 状态字寄存器在运算器和控制器中都有出现，它在运算器中标识运算状态和符号类型，在控制器中则保存控制条件和脉冲信号，体现了两者之间的界限模糊。
4. 指令译码和时序部件属于控制器，分别负责以一码方式分析指令和处理信号，而通用寄存器虽未深入讲解，但也是计算机系统中的重要组成部分。
5. 考点主要集中在运算器和控制器各部件的功能及其分类，即明确某个部件属于运算器还是控制器，以及它们在计算机系统中的具体作用。

![[Pasted image 20250404210655.png]]









### 指令系统(分值0-2)

#### 考点1 - 指令的执行方式

指令执行: 取指-->分析-->执行->

计算机性能: '百万条指令/秒'来表示(MIPS, million instruction per second)计算机的运算速度, 并且计算机的字长越长, 处理能力越强.



**练习题**





#### 考点2 - 指令地址结构

##### 指令的格式

一条指令就是机器语言的一个语句, 它是一组有意义的二进制代码, 指令的基本格式如下:

| 操作码字段 | 地址码字段 |
| ---------- | ---------- |

##### 指令类型

操作码部分指出了计算机要执行什么性质的操作, 如加法,减法,取数,存数等. 

地址码字段需要包含**各操作数的地址及操作结果的存放地址**等, 从其地址结构的角度可以分为:

* 三地址指令
* 二地址指令
* 一地址指令
* 零地址指令

| OP  | A1  | A2  | A3  |
| --- | --- | --- | --- |




| OP   | A1   | A2   |
| ---- | ---- | ---- |



| OP   | A1   |
| ---- | ---- |



| OP   |
| ---- |





#### 考点3 - 寻址方式

##### 立即寻址

操作数直接在指令中, 速度快, 灵活性差

##### 直接寻址方式

指令中存放的是操作数的地址

##### 间接寻址方式

指令中存放了一个地址, 这个地址对应的内容是操作数的地址

##### 寄存器寻址方式

寄存器存放操作数(前面几种是放在主存储器中的)

##### 寄存器间接寻址方式

寄存器内存放的是操作数的地址(这个地址指向的是主存储器中的)





**例题:**

1.在寄存器简介寻址方式下, 操作数存放在()中.

A.栈空间

B.指令寄存器

**C.主存单元**

D.通用寄存器

> 寄存器寻址就是操作数存放在指定的寄存器中, 寄存器间接寻址是将操作数地址放在寄存器中,操作数放在主存单元中.



### 存储系统(分值0-2)

#### 考点1-层次化存储结构

![image-20250321145348750](assets/image-20250321145348750.png)



* 内存一般用于临时存储计算机运行时所需的程序,数据及运行结果
* 外存用于长期保存信息
* 寄存器位于CPU中,用于临时存放少量的数据,运算结果和正在执行的指令





#### 考点2-Cache

* 基于成本和性能方面的考虑, Cache(高速缓存)是为了解决相对较慢的主存与快速的CPU之间工作速度不匹配问题而引入的存储器
* Cache容量较小, 速度比主存快5-10倍, 存储的主存内容的副本
* 主存地址与Cache地址之间的转换工作由硬件自动完成
* 在计算机的存储系统中, Cache是访问速度最快的存储(若有寄存器, 则寄存器最快)
* 使用Cache改善系统性能的依据是**程序的局部性原理**

时间局部性: 某条指令一旦执行, 可能将会再次被执行; 某数据被访问, 可能将会再次被访问

空间局部性: 某程序一旦访问了某个存储单元, 其附近的存储单元也可能将会被访问.







#### 考点3-主存

#### 1.ROM和RAM

**ROM(只读存储器)**: ROM中的内容在厂家生产时写入, 其内容只能读出不能改变,断电后其中的内容不会丢失.

**RAM(随机存储器):** 既可以写入也可以读出, 断电后信息无法保存,只能用于暂存数据. RAM又可以分为SRAM和DRAM两种.
* **SRAM**: 不断电的情况下信息一直保持而不丢失.
* **DRAM**: 信息会随时间逐渐消失, 需要定时对齐进行刷新来维持信息不丢失. **主存主要构成就是它.**



思考题:

回收站和剪贴板分别占用内存还是外存的存储空间?



#### 2.存储容量单位

**字(Word)**: 计算机进行数据处理时, 一次存取,加工和传送的数据长度称为字. 字的位数可以是16位, 32位, 64位等.

字长: 计算机的字长是指CPU一次能处理的二进制位数。

**地址**: 整个内存被分成若干个存储单元, 每个单元用地址(唯一的编号)来标识

**位(b/bit)**: 存放一位二进制数

**字节(B/Byte)**: 8个二进制位为一个字节

1B = 8bit

1KB = 1024B

1MB  = 1024KB

1GB  = 1024MB

1TB  = 1024GB

1PB  = 1024TB

1EB  = 1024PB

1ZB  = 1024EB

1YB  = 1024ZB





### 总线系统

#### 考点1-性能指标

**总线的带宽(总线数据传输速率**: 单位时间内总线上传送的数据量, 即每秒钟传送MB的最大稳态数据传输率. 

总线的带宽  = 总线的工作频率 * 总线的位宽 / 8



**总线的位宽: **  能同时传送的二进制数据的位数, 或数据总线的位数, 即32位, 64位等总线宽度的概念. 总线的位宽越宽, 每秒钟数据传输率越大, 总线的带宽越宽.





**总线的工作频率:** 以MHZ为单位, 工作频率越高, 总线工作速度越快, 总线带宽越宽. 



#### 考点2-三总线系统

![26768901197-1-192.mp4_image](assets/26768901197-1-192.mp4_image.png)



**地址总线**

* 存储器的数据位宽与数据总线的宽度需要一一匹配，以实现高效数据传输

* 字长: 对应的位宽.



**地址总线宽度32位 => 4GB物理空间.**

```md
2^32 => 4GB 推导

1.地址总线为32位, 则cpu可以生成2^32个不同的地址
2.每个地址对应1个字节(8位), 每个存储单元存储1字节(8位)
3.总内存容量计算
 总容量 = 地址数量 * 每个地址的存储单元大小
 总容量 = 2^32地址 * 1字节/地址 = 2^32字节
 
4.将2^32字节转换位GB
* 计算机中 1GB=2^30字节
* 所以, 2^32字节= 2^30*2^2字节=1GB*4 = 4GB


```



**CPU寻址能力8kb, 地址总线宽度是?**

```md
8*2^10, 2^13, 地址总线13位
```



**题目:**

1.某DRAM芯片的存储容量为512K*16位, 则该芯片的地址线和数据线宽度分别是

A. 9, 16

B. 19, 16

C. 10,16

D. 512, 16

答案: 选B. 16位规定为数据总线的宽度, 存储单元512K, 即2^9*2^10, 也就是2^19.



2..() 是CPU一次能并行处理的二进制位数, 是CPU的主要技术指标之一.

A. 字节

B. 带宽

C. 位宽

**D. 字长**


3.某计算机的字长是32位, 内存容量是1GB, 若内存空间按字编址, 那么其地址范围是( )(用16进制表示)
A.`0000000-FFFFFFF`
B.`0000000-7FFFFFF`
C.`30000000-eFFFFFFF`
D.`300000000-7FFFFFFF`
```解析

字长是32位, 8bit=1B(字节) 32bit = 4B(字节)
内存容量: 1G = 2^30B(字节)

编址方式:
 * 按字节编址: 每个地址对应一个字节
 * 按字编址: 每个地址对应一个字(这里一个字是32位, 即4字节)

所以:
1G, 按字编址, 每个字是4字节.
总字数量 = 总字节/每个字的字节数 = 2^30 / 4 = 2^28

然后将2^28转换位16进制:
2^28 = (2^4)^7 = 16^7

16^7在十六进制中表示为1后面跟着7个0，即10000000（十六进制）。

因此，2^28 - 1 = FFFFFFF（十六进制）。

所以，地址范围是0x0000000到0x0FFFFFFF。

1G / 4B = 1024 * 1024 * 1024B / 4B = 1024 * 1024 * 256B = 256MB






```







### IO接口与设备(分值范围0-1)

#### 考点1-输入和输出设备的划分

![1-10IO接口与设备_image](assets/1-10IO接口与设备_image.png)

#### 考点2-cpu与外设之间的数据交换的方式

![1-10IO接口与设备_image (1)](assets/1-10IO接口与设备_image (1).png)



**问题: C**

![image-20250322211927623](assets/image-20250322211927623.png)







## 第二章-多媒体基础知识(1-3分)



![ef45950bf74141d4a537f211294ab43e](assets/ef45950bf74141d4a537f211294ab43e.jpg)









### 媒体的种类(分值0-1)

#### 考点1-媒体概念和分类(分值 0 -1)

![c9e6a39546b94873938d062ada4243ed](assets/c9e6a39546b94873938d062ada4243ed.jpg)



媒体的几种主要类型及其功能:

* 感觉媒体 

* 表示媒体（用于数据交换的编码，如图像编码）
* 表现媒体（用于输入输出的媒体，如键盘、显示器）
* 存储媒体（用于存储信息，如磁盘、光盘），
* 传输媒体（用于传输信息，如光纤、同轴电缆）



微型计算机系统中打印机和内存的分类

在微型计算机系统中，打印机被归类为输出设备，属于表现媒体；内存则用于存储信息，属于存储媒体。此外，还介绍了传输媒体（如光纤、同轴电缆）和表示媒体（如图示编码）等相关概念。





### 音频(分值0-2)

#### 考点1-基本参数

1. 幅度：声波的振幅，单位为分贝，直接影响声音的波形幅度。
2. 频率：决定人能接受的声音范围，正常人说话频率在300到3400赫兹，**人耳接收范围为20赫兹到20K赫兹。**
3. 次声波与超声波：次声波频率小于20赫兹，人耳听不到；超声波频率大于20K赫兹，同样超出人耳接收范围。
4. 乐器的频率：乐器的频率与人耳接收频率范围一致，即20赫兹到20K赫兹。
5. 基本参数理解：幅度、频率以及次声波与超声波的定义是音频处理和理解声音特性的重要基础。

![image-20250323141633334](assets/image-20250323141633334.png)



#### 考点2-声音信号的数字化

1. 声音信号的数字化过程包括采集、转换成二进制位数量化精度，以及形成统一编码以减少存储量或进行压缩。
2. 采样是将连续的模拟声音信号在时间轴上进行离散化的过程，采样频率应为声音最高频率的2倍，例如最高频率为2K赫兹时，采样频率需为4K赫兹。
3. 模数转换（AD转换）将模拟信号转换为数字信号，量化则用二进制表示声音信号数据，位数反映精度；之后进行编码，组织成声音文件，必要时进行压缩以减少存储量。
4. 数据传输率由采样频率、量化的位数（精度）和声道数（单声道或双声道）组成，这些参数共同决定了声音数据的传输效率。
5. 音频文件格式，如波形文件格式和MP3等，是在声音信号数字化和压缩过程后形成的最终文件格式，用于存储和传输声音数据。

![2-2音频_image (1)](assets/2-2音频_image (1).png)



**例题**

1.设语音信号的采样频率位16KHZ, 量化精度为10位, 单声道输出, 则每小时的数据量位()MB.

A. 160

B. 80

C. 68.66

D. 9.37

音频容量计算: 每秒容量 = **采样频率(Hz)** * **量化/采样位数(位)** * **声道数 / 8**

1KHz = 1000Hz  1MB = 1024KB = 1024*1024B

所以该结果是, 16*1000 * 10*1 / 8 * 60 * 60  / 1024 / 1024 约等于68.66MB











#### 考点3-音频文件格式

![2-2音频_image (2)](assets/2-2音频_image (2).png)

















### 图形和图像(分值1-3)

#### 1.图形和图像的区别

矢量图与点阵图、位图、灰度图是并列的概念，前者用于描述由数学公式和几何形状构成的图形，后者则指由像素点构成的图像。

![2-3 图像和图形_image](assets/2-3 图像和图形_image.png)





#### 2.图像的基本参数

![2-3 图像和图形_image (1)](assets/2-3 图像和图形_image (1).png)



#### 3.显示器的基本参数

![01667ca2d99142998b1d016f3612aaa0](assets/01667ca2d99142998b1d016f3612aaa0.png)



#### 4.图形文件格式

![2-3 图像和图形_image (2)](assets/2-3 图像和图形_image (2).png)

1. 图像文件格式的基础知识：**图像由二进制位表示，称为位图或点阵图像素图**，常见格式如BMP、GIF、PNG、JPG等是考试重点。
2. BMP是位图的标准格式，与设备无关；GIF为动图图像，采用无损压缩；PNG被视为GIF的替代品，熟悉这些格式足以应对考试。
3. 特殊图像文件格式区分：JPEG是静态图像的有损压缩格式，而MPEG是动态或运动图像文件格式，两者需区分。
4. 记忆常见图像文件格式：重点记忆BMP、GIF（动图）、PNG、JPG等格式，这些是考试中常出现的图像文件类型。
5. 除上述常见格式外，了解TIF、PCS等格式的基本信息也有助于更全面地掌握图像文件格式的知识体系，尽管它们在考试中出现的频率较低。



#### 题目

图形由直线和曲线的元素构成，属于矢量图

![image-20250323144455430](assets/image-20250323144455430.png)



![image-20250323144601191](assets/image-20250323144601191.png)







### 多媒体相关计算问题(分值0-1)



#### 考点1-容量计算

![image-20250323144740992](assets/image-20250323144740992.png)



* 除以8的原因: 将比特位转换为字节(1个字节 = 8个比特位)
* log2(256) 是求2的多少次方位256, 结果是8. 然后除以8位, 得出字节.



![image-20250323150020223](assets/image-20250323150020223.png)



* 扫描后像素点: 150*3 * 150*4 = `450*600`
* `450*600*`(24/8) = 810000











## 第三章 数据结构与算法(8-11分)



### 顺序表与链表(0-2)

#### 考点1-数据结构

![image-20250327152540910](assets/image-20250327152540910.png)



#### 考点2-顺序表

![3-1顺序表和链表_image](assets/3-1顺序表和链表_image.png)

1. **顺序表**是通过连续且静态分配的方式存储元素的，即在使用前需预先分配固定大小的空间，保证每个元素有固定的存放位置。
2. 访问操作的时间复杂度为O(1)，即无论访问哪个元素，都能一步到位，效率非常高。
3. 查找特定值的操作时间复杂度为O(N)，因为可能需要遍历整个数组来匹配该值，每次查找的概率相等。
4. 删除和插入元素的操作时间复杂度均为O(N)，这是因为操作需要移动顺序表中的元素以保持连续性，移动次数与元素位置有关。
5. 在含N个元素的顺序存储线性表中，等概率删除任意一个元素平均需要移动二分之N减一的元素，反映了操作的平均时间复杂度。



#### 考点3-链表

![3-1](assets/3-1顺序表和链表_image-2.png)


![3-1顺序表和链表_image (2)](assets/3-1顺序表和链表_image-2.png)

1. 链表是一种链式存储结构，不同于顺序存储方式，它由两大部分组成：具体的节点和指针方式。节点里面包含值，**而指针方式存放的是指向下一个节点的指针位置。**
2. 链表的主要特点是内存不连续，即前一个元素存放的下一个地址在存储中不一定是下一个元素。这意味着一个节点可能在内存中的任意位置，而非顺序排列。
3. 访问链表中的某节点，需要通过上一个节点提供的地址进行。每个节点中有一个指针变量，用于存储指向下一个节点的地址，这种结构使得链表的存储方式非连续，而是根据链向次序连接。
4. 链表的指针地址并非连续，而是根据链表的结构，按照前一个节点接下一个节点的顺序，将下一个节点的指针地址保存在前一个节点中，形成了链式结构。
5. 链表的存储方式与顺序存储不同，顺序存储是连续的，而链表的存储则根据节点间的指针连接，形成了非连续的存储特性。



##### 链表的基本概念和特殊类型

![3-1顺序表和链表_image (3)](assets/3-1顺序表和链表_image-3.png)



1. 链表的基本概念包括首节点、尾节点和头节点，其中头节点通常用he表示，不存放数据，只存放链表的首地址，以便于进行操作如删除和插入。
2.  首节点是头节点之后的第一个有效节点，它有具体的标号和指针指向，而头节点没有具体的标号和内容，仅用于存放链表的首地址。
3. 尾节点是链表中的最后一个节点，链表通过指针将每个节点（除头节点和尾节点外）与前驱和后继节点相连，其中头节点没有前驱，尾节点没有后继。
4. 头指针指向头节点，尾指针指向尾节点，这两种指针用于快速定位链表的开始和结束位置，便于操作。
5. 加入头节点的目的是提高链表操作的效率，尤其是在链表头部进行删除和插入操作时，使得这些操作更加便捷和快速。



![3-1顺序表和链表_image (4)](assets/3-1顺序表和链表_image-4.png)

1. 单链表是一种基本链表结构，由头指针指向头节点，接着是首节点（第一个有效节点），最后是尾节点，每个节点仅向后指向下一个节点。
2. 循环链表是在单链表的基础上，尾节点的指针不是指向空，而是回指到头指针，形成一个循环结构。
3. 双向链表是一种更复杂的链表结构，其中每个节点都有两个指针，一个指向后继节点，另一个指向前驱节点，实现了双向的链接。
4. 这三种链表结构（单链表、循环链表、双向链表）各有特点，适用于不同的数据处理场景和算法实现。





















#### 考点4-顺序存储和链式存储性能对比

![3-1顺序表和链表_image (5)](assets/3-1顺序表和链表_image (5).png)

1. 顺序存储与链式存储的性能对比：顺序存储的存储密度等于一，为静态分配；链式存储存储密度小于一，因需存储数据及指针，为动态分配。
2. 查找运算：顺序存储和链式存储的时间复杂度均可简化为O(N)，其中N代表数据量大小。
3. 读运算：顺序存储的时间复杂度为O(1)，即一次操作即可找到所需数据；链式存储的时间复杂度为O(N/2 + 1)，可简化为O(N)。
4. 插入运算：顺序存储在首位插入需移动N个元素，平均时间复杂度为O(N)；链式存储只需改变链式结构，时间复杂度为O(1)。
5. 删除操作：顺序存储删除首位元素需移动N-1个元素，平均时间复杂度为O(N)；链式存储只需改变链式结构，时间复杂度为O(1)。



![3-1顺序表和链表_image (6)](assets/3-1顺序表和链表_image (6).png)



![3-1顺序表和链表_image (7)](assets/3-1顺序表和链表_image (7).png)



1. 数据结构的逻辑与存储结构分为线性与非线性，以及顺序和链式存储。顺序表通过相邻元素的相邻存储实现，而链表则通过指针将不相邻的元素联系起来。
2. 链表的基本类型包括单链表、双链表和循环链表，每种类型有其独特的特性和应用场景，需要对这些概念和名词有深入理解。
3. 单链表、双链表和循环链表是链表的三种主要形式，它们在元素的连接方式、访问和操作上存在显著差异
4. 性能对比是理解数据结构的关键，需要掌握在读操作、查找、插入和删除操作上，顺序表和链表的性能差异，通过对比表格来直观理解这些操作的效率。
5. 通过以上知识点的介绍，我们能够更深入地理解顺序表和链表的特性、类型以及在不同操作下的性能表现，这对于选择合适的数据结构解决实际问题至关重要。





### 数组(0-1)

#### 考点1 数组的概念
![[3-2数组_image.png]]
1. 数组是由N个数据类型相同的元素组成的一个序列或集合，所有元素必须定义为同一类型，例如整型。
2. 数组的元素在内存中必须连续存储，从第零号位置开始，依次占据第一、第二、直到N-1号位置，确保空间上的连续性。
3. 每个数组元素占用的存储单元大小相同，无论元素的具体内容，它们在内存中占据的空间大小一致。
4. 数组元素的下标有序，从零开始计数，直至N-1，形成一个有序的序列，便于通过下标访问特定元素。
5. 总结来说，数组是一种类型相同的元素按照顺序连续存放，并且每个元素存储空间大小一致的数据结构。


#### 考点2-一维数组
![[3-2数组_image-1.png]]

1. 一维数组的存储地址计算方式基于**首地址A加上I乘以L**，其中A表示数组的首地址，即A0的地址，I表示元素的位序，L表示每个单位元素所占用的存储单元。
2. 首地址A0指的是数组的第一个位置的地址，对于数组A，A0即为其首地址，A7的地址计算则为首地址A0加上七倍的L，因为A7位于第八位，从零开始标号。
3. 每个元素占据的存储单元数量相同，例如，若每个元素占据三个存储单元，计算AI的偏移量时，应在首地址基础上加上I乘以3，即偏移量为I*3。
4. 在计算偏移量时，考虑到每个元素占据的存储空间，例如，若首地址为100，每个元素占据三个存储单元，则AI的地址为100加上I乘以3，反映了一维数组中元素地址的计算逻辑。
5. 接下来将讨论二维数组的存储和地址计算，相比于一维数组，二维数组的地址计算会更为复杂，涉及更多的维度和计算步骤。

#### 考点2-二维数组
![[3-2数组_image-2.png]]


1. 二维数组表示形式不同于一维数组，具有行号和列号两个维度，如A34表示3行4列的数组。
2. 二维数组的标号从零开始，对于A34来说，行标号范围是0到2，列标号范围是0到3。
3. 二维数组可以按照按行存储的方式，将多维数据转化为一维存储，例如先存放第一行所有元素，再存放第二行，以此类推。
4. 按行存储时，特定元素的位置可以通过计算首地址加上相应的偏移量来确定，例如A22的位置距离首地址A00有10个单位的距离。
5. 在按行存储的情况下，寻找特定元素的偏移量计算对于理解和操作二维数组至关重要，有助于在计算机内存中快速定位元素。

![[3-2数组_image-3.png]]


1. 为了找到二维数组中某个元素的偏移量，首先需要确定该元素的具体位置，即它的行号和列号，以零开始标号。
2. 二维数组按行进行存储，所以要计算某元素的偏移量，首先需确定它位于`第I+1`行，`第J+1`列，因为行和列的编号从零开始。
3. 接下来计算位于该元素前面的行数，即I行，每行包含M个元素，因此前面的元素总数为I * M。
4. 然后计算该元素在当前行中的位置，距离它前面还有J个元素，因为它的列号为J+1，从零开始计数。
5. 最终，该元素的偏移量计算公式为`I * M + J`，这代表了从数组首地址到该元素的元素个数，即偏移量。



6. 在按行存储的情况下，一个元素的存储地址计算公式为 M * I + J * line + A00，其中 M * I + J * line 是偏移量，A00 是数组的首地址。
7. 偏移量 M * I + J * line 的计算中，M 表示每行的元素数量，I 表示行数，J 表示列数，line 表示每个数组的长度或存储位置的大小。
8. 计算偏移量时，是否加上首地址 A00 可以根据情况而定，两种计算方式本质上没有区别，都是为了计算出元素相对于首地址的偏移量。
9. 在按列存储的情况下，元素的偏移量计算会有所不同，需要考虑前面列和行的总元素数量，以确定该元素距离首地址 A00 的具体位置。
10. 按列存储时，偏移量的计算需考虑到每列元素的数量和已存在的列数及行数，以准确确定目标元素的存储地址。

#### 二维数组按行和按列存储的计算方法
![[Pasted image 20250401152229.png]]


1. AIJAI阶元素的存储位置首先需要计算前J列的元素总数，每列有N行，从0到N-1共计N行。
2. 计算J+1列上的元素行数，由于在I+1行上，因此其前面有I行的元素，需先计算这些元素的总量。
3. 根据上述计算，可得出复用公式为：J乘以N（每列的行数）加上I（前面的行数），即N*J + I。
4. 每个地址的空间大小为n ln，因此计算出的偏移量需乘以n ln，即(N*J + I) * n ln。
5. 最终存储地址是在计算出的偏移量基础上，加上数组的首地址，完成AIJAI阶元素的存储位置计算。



![[Pasted image 20250401152355.png]]

1. 在具体情况下，一维数组的计算方式为A加上I，而二维数组按列存放则有不同的计算方法，但这些计算方式并不是固定不变的。
2. 首先，需要确定行和列的索引是否分别对应于I和J，同时还要考虑索引是否是从零开始的。
3. 如果索引不是从零开始，那么在计算时需要对I和J进行调整，即使用I减1和J减1，以适应实际情况。
4. 公式并不是一成不变的，它需要根据具体情况进行调整，特别是在索引开始位置不为零的情况下。
5. 通过实际的题目计算，可以进一步发现和理解在不同情况下的计算区别和规律，从而更好地掌握数组计算的灵活运用。


#### 题目
![[Pasted image 20250401152952.png]]




#### 总结
![[Pasted image 20250401153020.png]]
1. 偏移量的计算方式是元素的个数乘以每个元素占用的单元数，存储位置则等于偏移量加上首地址。
2. 计算行数需要观察行号的变化，而列数的计算则需要观察列号的变化。
3. 总个数的计算方法是最大编号减去最小编号后再加上一，这个加一的操作确保了包含最小编号在内的所有编号都被计算在内。
4. 举例来说，从编号零开始到编号7，即7-0+1，总共应该有八个数据单元，这包括了0,1,2,3,4,5,6,7这八个单元。
5. 这个总结涵盖了计算偏移量、存储位置、行数、列数以及总个数的关键知识，对于理解数据存储和计算非常重要。



### 矩阵
![[Pasted image 20250401180906.png]]

#### 考点1 特殊矩阵


#### 考点2 非特殊矩阵

##### 稀疏矩阵
![[Pasted image 20250401180839.png]]


#### 题目
![[Pasted image 20250401180855.png]]



### 栈和队列(分值0-2)

![[Pasted image 20250401181838.png]]



#### 考点1-栈和队列

![[Pasted image 20250401181912.png]]

* 队列和栈属于逻辑结构中的线性结构
* 队列遵循**先进先出（FIFO）原则**，类似于生活中的排队现象，排在前面的优先享受服务。
* 栈遵循**先进后出（LIFO）原则**，即先放入的元素最后被取出，后放入的元素先被取出。
* 在队列中，队头用于删除（出队）元素，队尾用于插入（入队）元素，确保入队序列和出队序列保持相等，体现先进先出特性。
* 循环队列是一种特殊的队列形式，通过利用数组的循环特性，有效解决队列在顺序存储结构中可能出现的“**假溢出**”问题。
* 栈和队列的使用场景广泛，队列常用于需要保持元素处理顺序的场景，而栈则适用于需要后进先处理的场景，如函数调用、表达式求值等。

#### 循环队列
![[Pasted image 20250401182927.png]]


### 树的基本性质

![[Pasted image 20250401184736.png]]


#### 考点1-树的基本概念

![[Pasted image 20250401184800.png]]

树是什么?
> 是n(n>=0)个结点的有限集合. 当n=0时称为空树.

![[Pasted image 20250401190108.png]]
**双亲, 孩子和兄弟**


**节点的度**
> 一个节点的子树的个数记为该节点的度.

例如, B的度为2, C的度为0, D的度为0.

**叶子节点(终端节点)**
>度为零的节点


**内部节点(分支/非终端)**
>度不为0的节点称为分支节点或非终端节点. 除根节点之外, 分支节点也称为内部节点.

**节点的层次**
>根为第一层; 根的孩子为第二层, 以此类推

**树的高度**
>一棵树最大层数记为树的高度(或深度).

**有序(无序)树**
>若将树种节点的各子树看成是从左到右有次序关系, 即不能交换次序, 则称该树为有序树, 否则称为无序树.



#### 考点2-二叉树的划分

![[Pasted image 20250401194821.png]]


**满二叉树**
> 每一层的节点数都是满的，每一层的节点数达到最大

**完全二叉树**
>在层次遍历中，从上到下，从左到右的顺序进行，即使某些层的节点数未达到最大，但节点的分布遵循从左到右的原则，没有跳过任何左子节点直接添加右子节点的情况


**非完全二叉树**
>与完全二叉树的区别在于，它在层次遍历的过程中，可能出现未在左子节点完全添加完的情况下就添加了右子节点，或者在某一层未满的情况下就开始添加下一层的节点。



#### 二叉树特点
![[Pasted image 20250401195009.png]]

 **1. 最少层数（完全二叉树）：​**
- ​**公式**：深度k满足 2^(k-1) ≤ 节点数 < 2^k
- ​**计算**：
    - 2^6 = 64 < 65 → 当前层未满
    - 2^7 = 128 > 65 → 最少需要7层

​**2. 最多层数（退化成链表）：​**

- 每层仅1个节点 → 65层


![[Pasted image 20250402194931.png]]



### 树的遍历
![[Pasted image 20250402200353.png]]


#### 考点1-二叉树的遍历方式
![[Pasted image 20250402200415.png]]


前序遍历: 1 2 4 5 7 8 3 6
中序遍历: 4 2 7 8 5 1 3 6
后序遍历: 4 8 7 5 2 6 3 1
#### 考点2-由前序,中序遍历序列构造二叉树
![[Pasted image 20250402200720.png]]

二叉树:
```md
     A
    B   C
 H    F  G
     D
     E
```

![[Pasted image 20250402203704.png]]






### 特殊二叉树
![[Pasted image 20250403205835.png]]

特殊二叉树主要分为两种类型：二叉查找树（二叉排序树）和哈夫曼树，它们属于一类特殊的二叉树，具有不同的记录和查找方式

#### 考点1-二叉查找树
![[Pasted image 20250403205920.png]]








#### 考点2-哈夫曼树
![[Pasted image 20250403210713.png]]


![[Pasted image 20250403211144.png]]





![[Pasted image 20250403211247.png]]

1. 对于一棵二叉排序树，通过中序遍历可以得到节点关键字的有序序列。
2. 中序遍历的顺序遵循左子树-根节点-右子树的规则，确保了关键字从小到大的排序。
3. 二叉排序树的特性保证了左子树的所有节点小于根节点，而根节点又小于右子树的所有节点。4
4. 例题考察的是通过特定遍历方式获取二叉排序树节点关键字的有序序列，正确答案为中序遍历。
5. 总结可知，若需获取二叉排序树中节点关键字的有序序列，应采用中序遍历方法。












### 3-8 图

![[Pasted image 20250402212558.png]]



#### 考点1-图的分类
![[Pasted image 20250402212614.png]]


N个顶点的无向图和有向图的完全图边数分别为**N*(N-1)/2和N*(N-1)**，其中无向图边数为有向图的一半，因为无向图中的边被重复计算

连通图定义为任意两个顶点间都有一条路径相连，与完全图的区别在于完全图要求任意两个顶点间都有直接的边相连，而连通图只需存在路径即可。N个顶点的连通图至少需要N-1条边。



#### 考点2-图的转换
![[Pasted image 20250402215920.png]]




### 4 C语言程序设计之分支

![[Pasted image 20250403215831.png]]


#### 考点1-关系运算符
![[Pasted image 20250403215904.png]]

算术运算符 > 关系运算符 > 赋值运算符


![[Pasted image 20250403220001.png]]



#### 考点2-逻辑运算符
![[Pasted image 20250403220017.png]]


![[Pasted image 20250403220110.png]]
![[Pasted image 20250403220136.png]]![[Pasted image 20250403220208.png]]


![[Pasted image 20250403220223.png]]

#### 考点3-if单分支结构

练习:
补全代码, 判断今年是否是闰年.
```c
#include<stdio.h>
void main()
{
	int year = 2018;
	if (year % 4 == 0 &&(year % 100 != 0) || (year % 400 == 0) )
		printf("%s\n", "今年是闰年");
	else
		printf("%s\n", "今年是平年");
}
```


#### 考点5-多重if-else if分支


#### 考点6-if...else嵌套结构



#### 考点7-switch多分枝结构



### 操作系统
![[Pasted image 20250403222951.png]]



![[Pasted image 20250403222912.png]]



#### 考点1-进程的三态模型

![[Pasted image 20250403223022.png]]
#### 考点2-信号量机制
![[Pasted image 20250403223054.png]]



#### 考点3-同步和互斥
![[Pasted image 20250403223114.png]]
![[Pasted image 20250403223123.png]]
 1. P操作用于申请资源，V操作用于释放资源，两者不存在先后顺序，但共同管理资源的分配和释放。
 2. 执行P操作时，信号量S减一，若S小于零，表示资源不足，当前进程需进入等待队列；若资源足够，则进程继续执行。
 3. V操作用于释放资源，信号量S加一，若S小于等于零，表示有进程在等待资源，此时会唤醒等待队列中的一个进程，分配给它释放的资源。
 4. PV操作的核心在于：P操作确保资源的合理申请，避免资源过度消耗；V操作保证资源的有效释放，防止死锁发生，维持系统稳定运行。
 5. 通过理解PV操作的基本原理，可以解决相关例题，如分析特定年份的真题，掌握PV操作在实际问题中的应用，加深对操作系统资源管理机制的理解。

![[Pasted image 20250403223728.png]]
1. 系统中有N个并发进程共享资源R，资源R的可用数为3。
2. 进行PV操作时，向量S的取值范围表示资源的等待数和剩余数，负数表示等待的进程数，非负数表示剩余资源数。
3. 初始资源数为3，当N个进程中有3个进程使用资源后，剩余资源数变为0，此时等待资源的进程数为N-3。
4. 因此，向量S的取值范围应从负N减3（表示等待资源的进程数）到3（初始资源数），即选项A：负N减3到3。
5. 根据上述分析，正确答案是A，即向量S的取值范围是负N减3到3。



#### 设备管理

##### 考点1-设备管理的基本概念
![[Pasted image 20250403224254.png]]



##### 考点2-磁盘管理
![[Pasted image 20250403224309.png]]



**磁盘调度算法**

 1. 先来先服务算法：这是最简单的调度算法，按照请求的顺序进行服务。
 2. 最短寻道时间优先调度算法：从等待的访问者中挑选寻道时间最短的那个进行服务，优先处理距离最近的请求。
 3. 电梯调度算法：磁头沿一个方向移动，处理沿途的请求，直到达到边界再反向移动，类似于电梯的上下运动。
 4. 单向扫描调度算法：磁头从外向内或从内向外单向扫描，处理请求，到达边界后不返回，而是从边界重新开始扫描，只在一个方向上进行。
 5. 磁盘清理与碎片整理：包括清理系统垃圾文件、日志文件、临时文件、备份文件等，以优化磁盘性能和存储空间。


**磁盘清理和磁盘碎片整理**
 1. 碎片整理是针对Windows系统中普通硬盘的操作，而固态硬盘通常不需要进行碎片整理。
 2. 磁盘管理包括设备清理和碎片整理等，是Windows电脑使用者熟悉的常规操作。
 3. 在磁盘移臂调度算法中，单向扫描算法在返程时不响应进程访问磁盘的请求，因为它仅在单向移动时进行访问操作。
 4. 磁盘管理的基本概念和技术指标包括存储容量、平均存取时间、寻道时间，以及由磁道搜索、扇区搜索、数据传输三个部分组成的读取时间。
 5. 总结磁盘管理涉及设备分类、技术指标以及移臂调度算法，其中单向扫描算法在特定情况下不响应磁盘访问请求。

